<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MY_SUJBOT - Knowledge Graph Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 30px;
            background: #f8f9fa;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }

        .stat-number {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .controls {
            padding: 20px 30px;
            background: white;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 500;
            color: #333;
        }

        select, input[type="range"] {
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }

        input[type="range"] {
            width: 150px;
        }

        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        #graph-container {
            position: relative;
            width: 100%;
            height: 700px;
            background: #fafafa;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s;
        }

        .node:hover {
            stroke-width: 3px;
        }

        .node-label {
            font-size: 11px;
            pointer-events: none;
            text-anchor: middle;
            fill: #333;
            font-weight: 500;
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.4;
            stroke-width: 1.5px;
        }

        .link-label {
            font-size: 9px;
            fill: #666;
            pointer-events: none;
        }

        .legend {
            padding: 20px 30px;
            background: white;
            border-top: 1px solid #e0e0e0;
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }

        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 300px;
            display: none;
        }

        .info-panel.active {
            display: block;
        }

        .info-title {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .info-item {
            margin: 8px 0;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .info-label {
            font-weight: 500;
            color: #666;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f0f0f0;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
            padding: 0;
        }

        .close-btn:hover {
            background: #e0e0e0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üï∏Ô∏è Knowledge Graph Visualization</h1>
            <div class="subtitle">MY_SUJBOT Unified Knowledge Graph</div>
        </header>

        <div class="stats" id="stats"></div>

        <div class="controls">
            <div class="control-group">
                <label for="entity-type-filter">Filter by Entity Type:</label>
                <select id="entity-type-filter">
                    <option value="all">All Types</option>
                </select>
            </div>

            <div class="control-group">
                <label for="min-confidence">Min Confidence:</label>
                <input type="range" id="min-confidence" min="0" max="1" step="0.1" value="0">
                <span id="confidence-value">0.0</span>
            </div>

            <div class="control-group">
                <label for="max-nodes">Max Nodes:</label>
                <select id="max-nodes">
                    <option value="50">50</option>
                    <option value="100" selected>100</option>
                    <option value="200">200</option>
                    <option value="500">500</option>
                    <option value="all">All</option>
                </select>
            </div>

            <button onclick="resetGraph()">Reset View</button>
        </div>

        <div id="graph-container">
            <div id="info-panel" class="info-panel">
                <button class="close-btn" onclick="closeInfoPanel()">√ó</button>
                <div id="info-content"></div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-title">Entity Types</div>
            <div class="legend-items" id="legend-items"></div>
        </div>
    </div>

    <script>
        // Color scheme for entity types
        const typeColors = {
            'clause': '#667eea',
            'topic': '#f093fb',
            'regulation': '#4facfe',
            'organization': '#43e97b',
            'date': '#fa709a',
            'standard': '#feca57'
        };

        let graphData = null;
        let svg, simulation;

        // Load and process the knowledge graph
        async function loadKnowledgeGraph() {
            try {
                const response = await fetch('../vector_db/unified_kg.json');
                graphData = await response.json();

                // Calculate statistics
                updateStats(graphData);

                // Populate entity type filter
                populateEntityTypeFilter(graphData);

                // Create legend
                createLegend();

                // Initialize graph
                renderGraph(graphData);
            } catch (error) {
                console.error('Error loading knowledge graph:', error);
                document.getElementById('graph-container').innerHTML =
                    '<div style="padding: 40px; text-align: center; color: #999;">Error loading knowledge graph data</div>';
            }
        }

        function updateStats(data) {
            const entityTypes = {};
            data.entities.forEach(e => {
                entityTypes[e.type] = (entityTypes[e.type] || 0) + 1;
            });

            const statsHTML = `
                <div class="stat-card">
                    <div class="stat-number">${data.entities.length}</div>
                    <div class="stat-label">Total Entities</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${data.relationships.length}</div>
                    <div class="stat-label">Total Relationships</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${Object.keys(entityTypes).length}</div>
                    <div class="stat-label">Entity Types</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${entityTypes.clause || 0}</div>
                    <div class="stat-label">Clauses</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${entityTypes.regulation || 0}</div>
                    <div class="stat-label">Regulations</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${entityTypes.organization || 0}</div>
                    <div class="stat-label">Organizations</div>
                </div>
            `;
            document.getElementById('stats').innerHTML = statsHTML;
        }

        function populateEntityTypeFilter(data) {
            const types = [...new Set(data.entities.map(e => e.type))].sort();
            const select = document.getElementById('entity-type-filter');

            types.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                select.appendChild(option);
            });

            select.addEventListener('change', () => renderGraph(graphData));
        }

        function createLegend() {
            const legendItems = document.getElementById('legend-items');
            Object.entries(typeColors).forEach(([type, color]) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${color};"></div>
                    <span>${type.charAt(0).toUpperCase() + type.slice(1)}</span>
                `;
                legendItems.appendChild(item);
            });
        }

        function renderGraph(data) {
            const container = document.getElementById('graph-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Get filter values
            const typeFilter = document.getElementById('entity-type-filter').value;
            const minConfidence = parseFloat(document.getElementById('min-confidence').value);
            const maxNodes = document.getElementById('max-nodes').value;

            // Filter entities
            let filteredEntities = data.entities.filter(e => {
                if (typeFilter !== 'all' && e.type !== typeFilter) return false;
                if (e.confidence < minConfidence) return false;
                return true;
            });

            // Limit nodes if specified
            if (maxNodes !== 'all') {
                filteredEntities = filteredEntities
                    .sort((a, b) => b.confidence - a.confidence)
                    .slice(0, parseInt(maxNodes));
            }

            const entityIds = new Set(filteredEntities.map(e => e.id));

            // Filter relationships to only include those between filtered entities
            const filteredRelationships = data.relationships.filter(r =>
                entityIds.has(r.source_entity_id) && entityIds.has(r.target_entity_id)
            );

            // Clear previous graph
            d3.select('#graph-container svg').remove();

            // Create SVG
            svg = d3.select('#graph-container')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Add zoom behavior
            const g = svg.append('g');

            svg.call(d3.zoom()
                .extent([[0, 0], [width, height]])
                .scaleExtent([0.1, 8])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                }));

            // Create force simulation
            simulation = d3.forceSimulation(filteredEntities)
                .force('link', d3.forceLink(filteredRelationships)
                    .id(d => d.id)
                    .distance(100))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));

            // Create links
            const link = g.append('g')
                .selectAll('line')
                .data(filteredRelationships)
                .enter()
                .append('line')
                .attr('class', 'link')
                .attr('stroke-width', d => d.confidence * 2);

            // Create nodes
            const node = g.append('g')
                .selectAll('circle')
                .data(filteredEntities)
                .enter()
                .append('circle')
                .attr('class', 'node')
                .attr('r', d => 5 + d.confidence * 10)
                .attr('fill', d => typeColors[d.type] || '#999')
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('click', showEntityInfo);

            // Add labels
            const label = g.append('g')
                .selectAll('text')
                .data(filteredEntities)
                .enter()
                .append('text')
                .attr('class', 'node-label')
                .attr('dy', -15)
                .text(d => d.value.length > 30 ? d.value.substring(0, 27) + '...' : d.value);

            // Update positions on each tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => {
                        const source = filteredEntities.find(e => e.id === d.source_entity_id);
                        return source ? source.x : 0;
                    })
                    .attr('y1', d => {
                        const source = filteredEntities.find(e => e.id === d.source_entity_id);
                        return source ? source.y : 0;
                    })
                    .attr('x2', d => {
                        const target = filteredEntities.find(e => e.id === d.target_entity_id);
                        return target ? target.x : 0;
                    })
                    .attr('y2', d => {
                        const target = filteredEntities.find(e => e.id === d.target_entity_id);
                        return target ? target.y : 0;
                    });

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function showEntityInfo(event, d) {
            const infoPanel = document.getElementById('info-panel');
            const infoContent = document.getElementById('info-content');

            // Get connected relationships
            const connectedRels = graphData.relationships.filter(r =>
                r.source_entity_id === d.id || r.target_entity_id === d.id
            );

            infoContent.innerHTML = `
                <div class="info-title">${d.value}</div>
                <div class="info-item">
                    <span class="info-label">Type:</span> ${d.type}
                </div>
                <div class="info-item">
                    <span class="info-label">Confidence:</span> ${(d.confidence * 100).toFixed(0)}%
                </div>
                <div class="info-item">
                    <span class="info-label">Source chunks:</span> ${d.source_chunk_ids.length}
                </div>
                <div class="info-item">
                    <span class="info-label">Connected relationships:</span> ${connectedRels.length}
                </div>
                ${d.normalized_value ? `
                <div class="info-item">
                    <span class="info-label">Normalized:</span> ${d.normalized_value}
                </div>
                ` : ''}
            `;

            infoPanel.classList.add('active');
        }

        function closeInfoPanel() {
            document.getElementById('info-panel').classList.remove('active');
        }

        function resetGraph() {
            document.getElementById('entity-type-filter').value = 'all';
            document.getElementById('min-confidence').value = 0;
            document.getElementById('confidence-value').textContent = '0.0';
            document.getElementById('max-nodes').value = '100';
            renderGraph(graphData);
        }

        // Event listeners
        document.getElementById('min-confidence').addEventListener('input', (e) => {
            document.getElementById('confidence-value').textContent = parseFloat(e.target.value).toFixed(1);
            renderGraph(graphData);
        });

        document.getElementById('max-nodes').addEventListener('change', () => {
            renderGraph(graphData);
        });

        // Initialize on load
        loadKnowledgeGraph();
    </script>
</body>
</html>
